require('dotenv').config(); const express = require('express'); const cors = require('cors'); const bcrypt = require('bcrypt'); const jwt = require('jsonwebtoken'); const db = require('./db'); const { authenticateJWT, requireRole } = require('./auth'); const { sendOncallAlert } = require('./mailer');

const app = express(); app.use(cors()); app.use(express.json()); const PORT = process.env.PORT || 4000; const SALT_ROUNDS = 10;

// Auth: register app.post('/auth/register', async (req,res)=>{ const { name,email,password,role }=req.body; if(!name||!email||!password) return res.status(400).json({error:'Missing fields'}); const hash=await bcrypt.hash(password,SALT_ROUNDS); const result=await db.query('INSERT INTO users(name,email,password_hash,role) VALUES($1,$2,$3,$4) RETURNING id,name,email,role',[name,email,hash,role||'teacher']); res.json(result.rows[0]);});

// Auth: login app.post('/auth/login', async (req,res)=>{ const { email,password }=req.body; const q=await db.query('SELECT id,name,email,password_hash,role FROM users WHERE email=$1',[email]); if(q.rowCount===0) return res.status(400).json({error:'Invalid credentials'}); const user=q.rows[0]; const ok=await bcrypt.compare(password,user.password_hash); if(!ok) return res.status(400).json({error:'Invalid credentials'}); const token=jwt.sign({id:user.id,email:user.email,role:user.role,name:user.name},process.env.JWT_SECRET,{expiresIn:'12h'}); res.json({token,user:{id:user.id,name:user.name,email:user.email,role:user.role}});});

// Users list (admin) app.get('/users',authenticateJWT,requireRole('admin'),async(req,res)=>{const q=await db.query('SELECT id,name,email,role,created_at FROM users ORDER BY created_at DESC');res.json(q.rows);});

// Students CRUD app.post('/students',authenticateJWT,async(req,res)=>{const {name,year,class:cls}=req.body;if(!name) return res.status(400).json({error:'Name required'});const q=await db.query('INSERT INTO students(name,year,class) VALUES($1,$2,$3) RETURNING *',[name,year,cls]);res.json(q.rows[0]);}); app.get('/students',authenticateJWT,async(req,res)=>{const q=await db.query('SELECT * FROM students ORDER BY created_at DESC');res.json(q.rows);}); app.get('/students/:id',authenticateJWT,async(req,res)=>{const id=req.params.id;const q=await db.query('SELECT * FROM students WHERE id=$1',[id]);if(q.rowCount===0) return res.status(404).json({error:'Not found'});const student=q.rows[0];const notes=(await db.query('SELECT * FROM notes WHERE student_id=$1 ORDER BY created_at DESC',[id])).rows;const points=(await db.query('SELECT * FROM points WHERE student_id=$1 ORDER BY created_at DESC',[id])).rows;res.json({student,notes,points});}); app.put('/students/:id',authenticateJWT,async(req,res)=>{const id=req.params.id; const {name,year,class:cls}=req.body; await db.query('UPDATE students SET name=$1, year=$2, class=$3 WHERE id=$4',[name,year,cls,id]);res.json({ok:true});}); app.delete('/students/:id',authenticateJWT,async(req,res)=>{const id=req.params.id; await db.query('DELETE FROM students WHERE id=$1',[id]); res.json({ok:true});});

// Notes app.post('/students/:id/notes',authenticateJWT,async(req,res)=>{const studentId=req.params.id; const {type,content}=req.body;if(!type||!content) return res.status(400).json({error:'Missing fields'});const q=await db.query('INSERT INTO notes(student_id,type,content,created_by) VALUES($1,$2,$3,$4) RETURNING *',[studentId,type,content,req.user.id]);res.json(q.rows[0]);});

// Points app.post('/students/:id/points',authenticateJWT,async(req,res)=>{const studentId=req.params.id; const {kind,value,reason}=req.body;if(!kind||!reason||typeof value!=='number') return res.status(400).json({error:'Missing fields'});const q=await db.query('INSERT INTO points(student_id,kind,value,reason,created_by) VALUES($1,$2,$3,$4,$5) RETURNING *',[studentId,kind,value,reason,req.user.id]);res.json(q.rows[0]);});

// OnCall app.post('/oncalls',authenticateJWT,async(req,res)=>{try{const {room,category,details}=req.body;if(!room||!category) return res.status(400).json({error:'Missing fields'});const insert=await db.query('INSERT INTO oncalls(requested_by,room,category,details) VALUES($1,$2,$3,$4) RETURNING ',[req.user.id,room,category,details]);const oncall=insert.rows[0];const admins=(await db.query("SELECT email,name FROM users WHERE role='admin' AND email IS NOT NULL")).rows;const adminEmails=admins.map(a=>a.email).filter(Boolean);if(adminEmails.length>0){await sendOncallAlert(adminEmails,{room,category,details,requestedByName:req.user.name,requestedByEmail:req.user.email,created_at:oncall.created_at});}res.json(oncall);}catch(e){console.error(e);res.status(500).json({error:'Server error'})}}); app.get('/oncalls',authenticateJWT,requireRole('admin'),async(req,res)=>{const q=await db.query('SELECT o., u.name as requested_by_name, u.email as requested_by_email FROM oncalls o LEFT JOIN users u ON o.requested_by = u.id ORDER BY o.created_at DESC');res.json(q.rows);});

app.listen(PORT,()=>console.log('Server running on',PORT));
